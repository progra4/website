<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    margin: 10px 13px 10px 13px;
}
a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
@media screen and (min-width: 768px) {
    body {
        width: 748px;
        margin:10px auto;
    }
}
</style>
<title>El Tao de Rails</title>
</head>
<body>
<h1>El Tao de Rails</h1>

<p>De ahora en adelante usaremos <a href="http://rubyonrails.org/">Ruby on Rails</a> para crear aplicaciones web. Ruby on Rails (llamémoslo RoR de ahora en adelante), es un <em>framework</em>: abstrae prácticas comunes y usa convenciones para hacer más rápido el desarrollo. Hoy haremos nuestra primera aplicación en ruby on rails.</p>

<p>En esta ocasión, estaremos haciendo la aplicación que quedó para el primer examen: un pequeño administrador de proyectos. Vamos a poder crear tareas (<code>tasks</code>) que estén asignadas a usuarios (<code>users</code>) y vamos a permitir a los usuarios <strong>autenticarse</strong>. Haremos cada una de estas cosas en una iteración aparte. Esta guía está influenciada por <a href="http://tutorials.jumpstartlab.com/projects/blogger.html">esta guía en jumpstartlabs</a> y el <a href="http://ruby.railstutorial.org/ruby-on-rails-tutorial-book">railstutorial</a></p>

<h2>git ready</h2>

<p>Todo el progreso de este proyecto será parte de tu evaluación. Para ello, esta vez te tocará hacer a vos una copia de este repositorio y trabajar sobre ella.</p>

<p>El repositorio original vivirá acá:</p>

<p><a href="https://github.com/progra4/tasks_app">https://github.com/progra4/tasks_app</a></p>

<p>Veamos cómo:</p>

<p>Usaremos algo llamado <code>fork</code>: crea una copia del repositorio original (<code>progra4/tasks_app</code>) y la guardará en tu cuenta personal (mi nombre es <code>lfborjas</code>, así que lo guardará en <code>lfborjas/tasks_app</code>), para hacer eso, es tan simple como dar click en el botón fork de la página del proyecto (señalado con una flecha):</p>

<p><img src="fork" alt="https://img.skitch.com/20120514-g9ydhtthq48stema91bcqmr2k1.jpg" /></p>

<p>Y, una vez que lo copiés, deberías ver algo similar a esto (notá la URL):</p>

<p><img src="hardcore_forking" alt="https://img.skitch.com/20120514-dh1rkr8qfugbchk3bajj1tfnie.jpg" /></p>

<p>Que desaparecerá después de unos segundos y te mostrará el mismo listado de archivos que el proyecto original.</p>

<p>Ahora,  <strong>desde tu copia</strong>, podés hacer un <code>git clone</code>.</p>

<p>Una vez que hagás un git clone, se espera que tengás <strong>al menos un commit</strong> por cada iteración/cambio significativo. En clase decidiremos qué será cada tarea.</p>

<h2>Preliminares</h2>

<p>Si es la primera vez que usás ruby on rails, vas a tener que instalar <a href="http://www.sqlite.org/">sqlite</a> y el <a href="http://rubygems.org/gems/rails/versions/3.2.3">gem de rails</a> (estaremos usando la versión <code>3.2.3</code>), asimismo, instalaremos el <a href="http://rubygems.org/gems/heroku/versions/2.25.0">gem de heroku</a> para hacer nuestra aplicación públicamente accesible.</p>

<p>Para instalar <code>sqlite</code> en <strong>linux</strong>, hacé lo siguiente:</p>

<pre><code>sudo apt-get install sqlite3 libsqlite3-dev
</code></pre>

<p>Para instaler <code>sqlite</code> <strong>mac OSX</strong> (asumiendo que tenés <a href="http://mxcl.github.com/homebrew/">homebrew</a> instalado):</p>

<pre><code>brew install sqlite
</code></pre>

<h2>Iteración 0. Creando la aplicación</h2>

<p>Rails gira en torno a la terminal: tanto para crear una aplicación nueva como para agregar modelos o controladores, todo está basado en <a href="http://guides.rubyonrails.org/command_line.html">utilidades de línea de comandos</a>. Los comandos <em>universales</em> (que funcionarían en cualquier aplicación) usan el comando <code>rails</code>, los que dependen del proyecto (como por ejemplo, hacer algo en la base de datos específica del proyecto), usan el comando <code>rake</code></p>

<p>Cuando querés crear una aplicación nueva en rails, usás el comando <code>rails new</code> seguido del nombre del proyecto:</p>

<pre><code>rails new tasks
</code></pre>

<p>Esto creará la carpeta <code>tasks</code> y mostrará varias líneas que comienzan por <code>create</code>:</p>

<pre><code>  create  
  create  README.rdoc
  create  Rakefile
  create  config.ru
  create  .gitignore
  create  Gemfile
  create  app
  …
</code></pre>

<p>Y otras tantas líneas que demuestran que se están instalando las <em>gems</em> de las que depende rails:</p>

<pre><code>run  bundle install
Fetching gem metadata from https://rubygems.org/.........
Using rack (1.4.1) 
Installing i18n (0.6.0) 
Installing multi_json (1.3.5) 
…

Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed
</code></pre>

<p>Dos cosas a notar ahí: rails crea un <em>montón</em> de carpetas y archivos, pero prestémosle atención a algunos de ellos:</p>

<ul>
<li><strong>config.ru</strong>: el archivo que usará <code>rack</code> para iniciar el servidor.</li>
<li><strong>Gemfile</strong>: el archivo donde declaramos todas las dependencias de nuestro proyecto, para declarar una dependencia usás <code>gem &lt;DEPENDENCIA&gt;</code> y las instalás usando <a href="http://gembundler.com/">bundler</a> con el comando <code>bundle install</code>. Así, hay un solo lugar donde estarán todas las gems de tu proyecto.</li>
<li>La carpeta <code>app</code>: aquí están agrupados todos los <code>models</code>, <code>views</code> y <code>controllers</code> de tu proyecto, es donde más trabajaremos</li>
<li>La carpeta <code>config</code>: aquí están diversas configuraciones/personalizaciones de tu proyecto, en especial, un par de archivos importantes:

<ul>
<li> <code>routes.rb</code>, define los <em>paths</em> (rutas), y que cumple con el concepto de <code>router/dispatch</code> que habíamos discutido previamente.</li>
<li><code>database.yml</code>: contiene la configuración para la base de datos</li>
</ul>
</li>
<li>La carpeta <code>db</code>, que contiene lo relacionado a la base de datos. En el archivo <code>db/schema.rb</code> encontraremos los campos que tienen los modelos.</li>
</ul>


<p>Usualmente, luego de crear un proyecto en rails, queremos seguirlo con <code>git</code>, así que podemos hacer esto:</p>

<pre><code>git init 
git add .
git commit -m "creado el proyecto en rails"
</code></pre>

<p>Si te fijás, <code>rails</code> generó el archivo <code>.gitignore</code> que tiene reglas que definen qué archivos debería ignorar git (hay archivos que nunca queremos tener, como archivos temporales que editores como gedit crean)</p>

<p>Una vez que creés el proyecto, podés levantar el servidor usando el comando <code>rails server</code></p>

<pre><code>rails server
</code></pre>

<p>Y vas a ver algo similar a esto, si todo sale bien</p>

<pre><code>=&gt; Booting WEBrick
=&gt; Rails 3.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-05-13 23:56:27] INFO  WEBrick 1.3.1
[2012-05-13 23:56:27] INFO  ruby 1.9.3 (2012-02-16) [x86_64-darwin11.3.0]
[2012-05-13 23:56:27] INFO  WEBrick::HTTPServer#start: pid=15206 port=3000
</code></pre>

<p>Si te fijás, hace exactamente lo mismo que hacíamos antes con <code>rackup start.ru -p 3000</code>, pero esta vez es un comando más estándar y más corto.</p>

<p>Una vez que hagás eso, podrías ir a <a href="http://localhost:3000">http://localhost:3000</a> y verías algo como esto:</p>

<p><img src="riding_rails" alt="https://img.skitch.com/20120514-jxfghu4xnditq3arxucidy2fq2.jpg" /></p>

<h2>Iteración 1: Tasks</h2>

<h3>1. Modelos</h3>

<p>Como ya sabemos, la parte central de muchas aplicaciones web son los modelos, así que concentrémonos en eso primero.</p>

<p>En rails, todo empieza con un <a href="http://railscasts.com/episodes/216-generators-in-rails-3">generador</a>: vos podrías agregar manualmente el archivo que representará la clase de tu modelo a la carpeta <code>app/models</code> y agregar el archivo que creará la tabla de tu modelo a la carpeta <code>db/migrate</code>, pero es tedioso escribir y memorizar tanto código y pasos, así que podés usar el generador de modelos (<code>rails generate model</code>) para que te ayude.</p>

<p>Para generar un modelo, usualmente le decís cómo se llamará y qué propiedades tendrá. En este momento, nuestras tareas tendrán sólo una descripción y prioridad, nos ocuparemos del responsable en la siguiente iteración. Así que lo haremos con este comando</p>

<pre><code>rails generate model Task description:string priority:integer
</code></pre>

<p>Si te fijás, después del nombre del modelo ponemos las propiedades con el tipo que han de tener. Este tipo es útil para la base de datos.</p>

<p>Deberías ver algo similar a esto:</p>

<pre><code>  invoke  active_record
  create    db/migrate/20120514062804_create_tasks.rb
  create    app/models/task.rb
  invoke    test_unit
  create      test/unit/task_test.rb
  create      test/fixtures/tasks.yml
</code></pre>

<p>Ahí te dice qué archivos creó. Los que nos importan son el que está en <code>db/migrate</code>
 y el que está en <code>app/models</code>. Hablemos un poco de la migración ahorita.</p>

<h4>Migraciones</h4>

<p>En una aplicación hecha en RoR se asume que vas a guardar las cosas en una base de datos, ¿qué es una base de datos? Un archivo glorificado: contiene tablas que representan un objeto; las columnas representan las propiedades del objeto y las filas representan instancias de cada objeto. Los programas que se encargan de gestionar bases de datos de este tipo se conocen como <em>relational database management systems (RDBMS)</em> y los más famosos en el mundo opensource son: <a href="http://www.mysql.com/">mySQL</a>, <a href="http://www.postgresql.org/">postgreSQL</a> y <a href="http://www.sqlite.org/">sqlite</a> (pero sqlite no es un RDBMS de verdad! Sólo sirve para usarlo como base de datos local porque es un programa liviano y no presenta inconvenientes, ¡nunca lo usés en un sitio de verdad!). Nosotros estamos usando acá sqlite, y si te fijás, eso está declarado en el archivo <code>config/database.yml</code>.</p>

<p>Pues bien, ahora que sabés sobre los RDBMS, tenés que saber que uno interactúa con ellos usando un lenguaje declarativo llamado <a href="http://en.wikipedia.org/wiki/Sql">SQL</a>, y una de las cosas que uno hace con SQL es decirle al RDBMS &ldquo;mirá, voy a tener una tabla con tales y tales columnas de tales y tales tipos&rdquo;. Este tipo de instrucciones se puede perfectamente <a href="http://dev.mysql.com/doc/refman/5.1/en/create-table.html">hacer</a> <a href="http://dev.mysql.com/doc/refman/5.1/en/alter-table.html">manualmente</a>. Pero estas instrucciones, además de difíciles, pueden variar de un RDBMS a otro. Pero no temás, ¡rails es tu amigo! Y aquí entra el concepto de <strong>migración</strong>: una migración es un script en ruby que crea o modifica tabla en el RDBMS. Así que cada vez que creés un modelo (decidás qué propiedades tendrá) o querás agregar o quitar una propiedad de un modelo, en vez de hacerlo directamente con el RDBMS, harás una migración. Por ejemplo, la migración que acabamos de crear (el archivo que está en <code>db/migrate</code> cuyo nombre termina en <code>create_tasks.rb</code>) se ve así:</p>

<pre><code>class CreateTasks &lt; ActiveRecord::Migration
  def change
    create_table :tasks do |t|
      t.string :description
      t.integer :priority

      t.timestamps
    end
  end
end
</code></pre>

<p>Si te fijás, se puede leer más o menos en inglés: &ldquo;crear la tabla <em>tasks</em> y dentro de ella: habrá una columna <em>string</em> que sea la descripción y una columna <em>integer</em> que sea la prioridad&rdquo;. También agregó una línea que dice <code>timestamps</code>. Los timestamps son dos columnas: <code>created_at</code> y <code>updated_at</code> que rails agrega por defecto a todas las tablas, son útiles para saber cuándo se creó y guardó una instancia o cuando se modificó una instancia, respectivamente. Una cosa a notar es la convención que <strong>creamos los modelos en singular (<code>Tasks</code>) pero las tablas tendrán el nombre en plural (<code>tasks</code>)</strong>.</p>

<p>Ahora bien, este archivo sólo <strong>declara</strong> qué hará la migración, pero aún no hemos hablado con la base de datos. Para que la migración se aplique, vas a correr un comando específico a tu aplicación (recordá que esos se corren con <code>rake</code>)</p>

<pre><code>rake db:migrate
</code></pre>

<p>Y si todo sale bien, verás algo como esto:</p>

<pre><code>==  CreateTasks: migrating ====================================================
-- create_table(:tasks)
   -&gt; 0.0012s
==  CreateTasks: migrated (0.0013s) ===========================================
</code></pre>

<p>Y, después de esto, después de que la tabla se haya creado en la base de datos, vas a fijarte que existe un nuevo archivo: <code>db/schema.rb</code>, este refleja la estructura actual de la base de datos (cuándo fue la última vez que cambió, qué tablas hay y qué columnas contienen), ahorita se ha de ver así:</p>

<pre><code>ActiveRecord::Schema.define(:version =&gt; 20120514062804) do

  create_table "tasks", :force =&gt; true do |t|
    t.string   "description"
    t.integer  "priority"
    t.datetime "created_at",  :null =&gt; false
    t.datetime "updated_at",  :null =&gt; false
  end

end
</code></pre>

<p>Si te fijás, <code>:version =&gt; 20120514062804</code> se refiere a la fecha, hora, minutos, segundos y milisegundos en que fue modificada la estructura de la base de datos por última vez (va a ser diferente para vos) y abajo hay algo similar a una migración, con todas las tablas y columnas.</p>

<p>Algo interesante a notar es la propiedad <code>:null =&gt; false</code> en las columnas <code>created_at</code>, esto es un <em>constraint</em> que significa que el valor de esta columna nunca debería estar vacío (de todas formas vos no vas a llenarlos prácticamente nunca, estos atributos los maneja rails automáticamente, sólo preocupate por las columnas que vos creés explícitamente).</p>

<p>Podés ver a los archivos en <code>db/migrate</code> como la intención de cambiar la base de datos y al archivo <code>db/schema</code> como el resultado de haber seguido esa intención.</p>

<p>Otra cosa que tenés que saber, aunque no salga en ninguno de los dos archivos anteriores</p>

<p>Ok, ahora que sabemos todo sobre las migraciones, veamos qué hay en nuestro modelo (en el archivo <code>app/models/Task.rb</code>):</p>

<pre><code>class Task &lt; ActiveRecord::Base
  attr_accessible :description, :priority
end
</code></pre>

<p>Si te fijás, no hay mucho: todos los métodos interesantes están en la superclase <code>ActiveRecord::Base</code>, dentro de poco jugaremos con ellos. Una cosa que te podés fijar es en el uso del método <code>attr_accessible</code>: no lo confundás con <code>attr_accessor</code>, que es un método de ruby, <code>attr_accessible</code> es un método de la librería <code>ActiveRecord</code> de rails y lo que significa es que estos atributos (<code>description</code> y <code>priority</code>) pueden ser modificados directamente por vos. Los atributos que no estén aquí listados no pueden ser cambiados (por ejemplo, los atributos <code>created_at</code> y <code>updated_at</code> no los podés modificar a través de métodos como <code>create</code> o <code>update</code>, estos métodos, que discutiremos dentro de poco, se conocen como métodos de <strong>mass assignment</strong>). Este modelo es similar a lo que hemos estado haciendo: representa un recurso, lo que podemos hacer con los recursos y se encarga de guardarlo en la base de datos y sacarlo de allí cuando lo necesitemos.</p>

<h4>Jugando con los modelos</h4>

<p>Como recordarás, a veces nos convenía probar las clases que hacíamos en <code>irb</code> para ver si funcionaban como esperábamos, usualmente abríamos una sesión de <code>irb</code> y escribíamos unos cuantos <code>require</code> para importar nuestras clases. En rails hay una convención divertida: <strong>no te toca importar prácticamente nada, todo se importa automáticamente al iniciar el servidor (o, como lo llama la gente de rails, <em>loading the environment</em>)</strong>. Y rails te ayuda hasta en la consola, dándote el comando <code>rails console</code></p>

<pre><code>rails console
</code></pre>

<p>Que carga una sesión de <code>irb</code> pero con todo tu &ldquo;entorno&rdquo; ya cargado. Escribilo, y verás algo como esto:</p>

<pre><code>Loading development environment (Rails 3.2.3)
1.9.3p125 :001 &gt;
</code></pre>

<p>Vamos a hacer una rápida sesión para ver qué encontramos:</p>

<pre><code>1.9.3p125 :001 &gt; Task
 =&gt; Task(id: integer, description: string, priority: integer, created_at: datetime, updated_at: datetime)
</code></pre>

<p>Rails tiene la decencia de cambiar el método <code>inspect</code> de la clase <code>ActiveRecord::Base</code> para mostrar todas las columnas que tiene la tabla. Como te decía, además de las dos que vos declaraste, agrega automáticamente a <strong>todos</strong> los modelos los atributos <code>id</code>, <code>created_at</code> y <code>updated_at</code>.</p>

<pre><code>1.9.3p125 :002 &gt; Task.all
  Task Load (0.3ms)  SELECT "tasks".* FROM "tasks" 
 =&gt; [] 
</code></pre>

<p>Aquí, muy interesantemente, nos está mostrando cómo el método <code>all</code> usa SQL para buscar <em>todas</em> las instancias de la clase <code>Task</code> en la tabla <code>tasks</code> de la base de datos. Al final nos devuelve un arreglo vacío, como es de esperar.</p>

<p>Probemos crear una instancia de <code>Task</code>:</p>

<pre><code>1.9.3p125 :003 &gt; i = Task.new(description: "aprender rails", priority: 10)
 =&gt; #&lt;Task id: nil, description: "aprender rails", priority: 10, created_at: nil, updated_at: nil&gt;
</code></pre>

<p>Tomá nota que esto <strong>sólo creó la instancia</strong>, pero no la ha guardado en la base de datos: por eso no le ha asignado un <code>id</code>, ni los timestamps. De modo que correr <code>Task.all</code> en este punto nos seguirá dando un arreglo vacío. Guardemos esta instancia a la base de datos usando el método <code>save</code>:</p>

<pre><code>1.9.3p125 :005 &gt; i.save
   (0.2ms)  begin transaction
  SQL (91.7ms)  INSERT INTO "tasks" ("created_at", "description", "priority", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 14 May 2012 07:32:22 UTC +00:00], ["description", "aprender rails"], ["priority", 10], ["updated_at", Mon, 14 May 2012 07:32:22 UTC +00:00]]
   (3.0ms)  commit transaction
 =&gt; true 
</code></pre>

<p>Incluso podés cambiar atributos de la instancia y volver a grabarla</p>

<pre><code>1.9.3p125 :014 &gt; i.priority = 6
 =&gt; 6 
1.9.3p125 :015 &gt; i.save
   (0.1ms)  begin transaction
   (0.4ms)  UPDATE "tasks" SET "priority" = 6, "updated_at" = '2012-05-14 07:42:52.258642' WHERE "tasks"."id" = 1
   (46.7ms)  commit transaction
 =&gt; true
</code></pre>

<p>(notá que esta vez usó la sentencia SQL <code>UPDATE</code> en lugar de <code>CREATE</code>, porque la fila ya existe en la base de datos)</p>

<p>Una vez más, rails nos explica qué pasos está tomando para hablar con el RDBMS, y, si logra guardar la instancia, nos devuelve <code>true</code>. Si volvemos a tratar de obtener todas las instancias:</p>

<pre><code>1.9.3p125 :006 &gt; Task.all
  Task Load (0.3ms)  SELECT "tasks".* FROM "tasks" 
 =&gt; [#&lt;Task id: 1, description: "aprender rails", priority: 10, created_at: "2012-05-14 07:32:22", updated_at: "2012-05-14 07:32:22"&gt;]
</code></pre>

<p>Tendremos, esta vez, un arreglo con un solo elemento. Probemos crear otra instancia, esta vez con el método <code>create</code>:</p>

<pre><code>1.9.3p125 :007 &gt; Task.create(description: "pasar la clase", priority: 6)
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "tasks" ("created_at", "description", "priority", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 14 May 2012 07:34:28 UTC +00:00], ["description", "pasar la clase"], ["priority", 6], ["updated_at", Mon, 14 May 2012 07:34:28 UTC +00:00]]
   (2.8ms)  commit transaction
 =&gt; #&lt;Task id: 2, description: "pasar la clase", priority: 6, created_at: "2012-05-14 07:34:28", updated_at: "2012-05-14 07:34:28"&gt; 
</code></pre>

<p>Si te fijás, este método hace la instancia y la guarda <em>en un solo paso</em> ¡conveniente! (espero que en este punto hayás notado que rails está obsesionado con hacerte fácil la vida). Ahora <code>Task.all</code> te debería dar un arreglo con dos elementos. Probemos con otros métodos: <code>count</code>, <code>where</code>, <code>exists?</code> y las variantes de <code>find</code>:</p>

<pre><code>1.9.3p125 :008 &gt; Task.count
   (0.3ms)  SELECT COUNT(*) FROM "tasks" 
 =&gt; 2 
1.9.3p125 :009 &gt; Task.where(priority: 6)
  Task Load (0.2ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."priority" = 6
 =&gt; [#&lt;Task id: 1, description: "aprender rails", priority: 6, created_at: "2012-05-14 07:32:22", updated_at: "2012-05-14 07:42:52"&gt;, #&lt;Task id: 2, description: "pasar la clase", priority: 6, created_at: "2012-05-14 07:34:28", updated_at: "2012-05-14 07:34:28"&gt;]
1.9.3p125 :010 &gt; Task.exists?(priority: 10)
  Task Exists (0.2ms)  SELECT 1 FROM "tasks" WHERE "tasks"."priority" = 10 LIMIT 1
 =&gt; false 
1.9.3p125 :011 &gt; Task.find(2)
  Task Load (0.4ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."id" = ? LIMIT 1  [["id", 2]]
 =&gt; #&lt;Task id: 2, description: "pasar la clase", priority: 6, created_at: "2012-05-14 07:34:28", updated_at: "2012-05-14 07:34:28"&gt; 
 1.9.3p125 :017 &gt; Task.find_by_priority(6)
  Task Load (0.2ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."priority" = 6 LIMIT 1
 =&gt; #&lt;Task id: 1, description: "aprender rails", priority: 6, created_at: "2012-05-14 07:32:22", updated_at: "2012-05-14 07:42:52"&gt;
 1.9.3p125 :018 &gt; Task.find_all_by_priority(6)
  Task Load (0.4ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."priority" = 6
 =&gt; [#&lt;Task id: 1, description: "aprender rails", priority: 6, created_at: "2012-05-14 07:32:22", updated_at: "2012-05-14 07:42:52"&gt;, #&lt;Task id: 2, description: "pasar la clase", priority: 6, created_at: "2012-05-14 07:34:28", updated_at: "2012-05-14 07:34:28"&gt;]
</code></pre>

<p>si te fijás, el método <code>find_by_priority</code> sólo devuelve el <em>primer</em> objeto que cumpla los requisitos, mientras que <code>where</code> y <code>find_all_by_priority</code> devuelven todos.</p>

<p>Y qué pasa si quisiéramos actualizar una instancia que está en la base de datos, usamos el método <code>update_attributes</code>:</p>

<pre><code>1.9.3p125 :022 &gt; i2 = Task.find(2)
  Task Load (0.2ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."id" = ? LIMIT 1  [["id", 2]]
 =&gt; #&lt;Task id: 2, description: "pasar la clase", priority: 6, created_at: "2012-05-14 07:34:28", updated_at: "2012-05-14 07:34:28"&gt; 
1.9.3p125 :023 &gt; i2.update_attributes(description: "pasar progra4", priority: 7)
   (0.1ms)  begin transaction
   (0.4ms)  UPDATE "tasks" SET "description" = 'pasar progra4', "priority" = 7, "updated_at" = '2012-05-14 07:54:26.321018' WHERE "tasks"."id" = 2
   (50.1ms)  commit transaction
 =&gt; true 
</code></pre>

<p>Y veamos qué cosas pueden salir mal:</p>

<pre><code>1.9.3p125 :019 &gt; Task.find(666)
  Task Load (0.1ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."id" = ? LIMIT 1  [["id", 666]]
ActiveRecord::RecordNotFound: Couldn't find Task with id=666
1.9.3p125 :020 &gt; Task.find_by_id(666)
  Task Load (0.3ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."id" = 666 LIMIT 1
 =&gt; nil
 1.9.3p125 :021 &gt; Task.where(id: 666)
  Task Load (0.2ms)  SELECT "tasks".* FROM "tasks" WHERE "tasks"."id" = 666
 =&gt; [] 
</code></pre>

<p>si te fijás, el método <code>find</code> explota si no encuentra lo que busca, mientras que los <code>find_by</code> y <code>where</code>, no.</p>

<p>Eso es todo con los modelos por ahora.</p>

<p>Este es un buen momento para hacer commit :)</p>

<p>Vas a encontrar más información sobre migraciones aquí: <a href="http://guides.rubyonrails.org/migrations.html">http://guides.rubyonrails.org/migrations.html</a>  y más sobre los métodos de <code>ActiveRecord::Base</code>, aquí: <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">http://api.rubyonrails.org/classes/ActiveRecord/Base.html</a></p>

<p>Y con esto podemos pasar a la siguiente parte de esta iteración.</p>

<h4>Validaciones</h4>

<p>En la primera parte vimos cómo rails nos ayuda a interactuar con la base de datos. Pero los modelos tienen aún otra responsabilidad: asegurarse que los datos están correctos. Por ejemplo, en esta aplicación no queremos:</p>

<ul>
<li>Tareas con descripciones en blanco</li>
<li>Tareas con descripciones repetidas</li>
<li>Tareas con prioridades menores que 0</li>
</ul>


<p>Para forzar a que estas reglas se cumplan, introduciremos el concepto de <strong>validación</strong>.</p>

<p>Rails nos ofrece ciertos métodos que podemos agregar a nuestras clases para forzar estas reglas, editemos el modelo que vive en <code>app/models/task.rb</code>:</p>

<pre><code> class Task &lt; ActiveRecord::Base
  attr_accessible :description, :priority

  validates_presence_of :description
  validates_uniqueness_of :description
  validates :priority, numericality: {:greater_than =&gt; 0}

  before_validation :clean_description, if: "description.present?"

  private
  def clean_description
    self.description = self.description.strip.capitalize
  end
 end
</code></pre>

<p>Hablemos de esto por partes:</p>

<ul>
<li><code>validates_presence_of</code> es un método que genera un validador para el atributo (o atributos) que se le provean. Valida que el atributo tenga un valor no-nulo</li>
<li><code>validates_uniqueness_of</code>: valida que el atributo (columna) sea único entre todas las filas ya existentes de la tabla</li>
<li><code>validates</code> es general, y sirve para construir validadores más complejos. En este caso validamos la <a href="http://guides.rubyonrails.org/active_record_validations_callbacks.html#numericality">&ldquo;numericality&rdquo;</a> del atributo <code>priority</code> para asegurarnos que sea mayor que cero.</li>
</ul>


<p>Además de los métodos que generaron validadores, tenemos otro método, que genera un &ldquo;callback&rdquo;. En RoR hay un concepto interesante con los modelos: <strong>eventos</strong>, cada vez que un modelo se crea, actualiza o destruye, ciertos eventos son reportados al sistema, y pueden ser usados por nosotros. En esta ocasión, estamos diciendo &ldquo;antes de que ocurra el evento <code>validation</code> quiero que un método se ejecute&rdquo;. Y estamos usando un símbolo para referirnos a un método privado que definimos después. Y, además, usamos la opción <code>if</code> para decir que ese método sólo debería ejecutarse si hay una descripción presente. El método en sí simplemente elimina espacios en blanco y capitaliza las descripciones.</p>

<p>Probemos las validaciones en una sesión de irb:</p>

<p>Y, ahora, es buena idea hacer otro commit.</p>

<p>Más información sobre validaciones y &ldquo;callbacks&rdquo; acá: <a href="http://guides.rubyonrails.org/active_record_validations_callbacks.html">http://guides.rubyonrails.org/active_record_validations_callbacks.html</a></p>

<h3>2. El router</h3>

<p>Ahora, no es divertido si sólo tenemos nuestros modelos en la aplicación; después de todo, es una aplicación web y todo el centro es HTTP. Según recordarás de los experimentos que hicimos en el primer parcial, todo el secreto de HTTP es poder usar los <em>verbos</em> y <em>rutas</em> para poder interactuar con los <em>recursos</em>. Ya tenemos un modelo que representa los recursos, ahora hablemos de cómo <em>configuraríamos</em> las rutas.</p>

<p>La convención de rails es que usemos los principios de arquitectura <a href="http://blog.steveklabnik.com/posts/2011-08-07-some-people-understand-rest-and-http">REST</a>. La forma de hacerlo es editando el archivo <code>config/routes.rb</code> y diciéndole a rails que tendremos nuestras tareas como <em>recursos</em>:</p>

<pre><code>Tasks::Application.routes.draw do
  resources :tasks
end
</code></pre>

<p>La convención en rails es ver las cosas como recursos, y las rutas y quién se encarga de ellas se decide automáticamente. Para ver las combinaciones de acción + ruta que nuestra aplicación espera entender, podemos usar el comando <code>rake routes</code>:</p>

<pre><code>    tasks GET    /tasks(.:format)          tasks#index
          POST   /tasks(.:format)          tasks#create
 new_task GET    /tasks/new(.:format)      tasks#new
edit_task GET    /tasks/:id/edit(.:format) tasks#edit
     task GET    /tasks/:id(.:format)      tasks#show
          PUT    /tasks/:id(.:format)      tasks#update
          DELETE /tasks/:id(.:format)      tasks#destroy
</code></pre>

<p>Esa es la tabla de rutas, si te fijás, es justo la convención que ya sabíamos. Expliquemos qué significa cada columna:</p>

<ul>
<li>La primera columna es el <em>alias</em> para la ruta. Así, la primera ruta, la que representa la colección de todos los <code>tasks</code> se llama, sorprendentemente, <code>tasks</code>, y las acciones que representan recursos extra, como <em>new</em> y <em>edit</em>, tienen su propio nombre. Recordá este concepto de alias para más tarde.</li>
<li>La segunda y tercera columnas son el verbo + ruta, como ya sabemos, eso representa una acción única en nuestra aplicación. Algo a notar aquí son los valores que parecen símbolos (<code>:format</code>, <code>:id</code>), estos son <strong>segmentos dinámicos</strong> de las rutas y serán incluidos en el hash <code>params</code> al que tienen acceso los controladores.</li>
<li>La última columna es parte de la convención: como dijimos que nuestro recurso se llama <code>tasks</code>, espera que exista un controlador llamado <code>tasks</code> (en realidad, <code>TasksController</code>) que tenga métodos para las siete acciones posibles sobre un recurso (<code>index</code>, <code>create</code>, <code>new</code>, <code>edit</code>, <code>show</code>, <code>update</code>, <code>destroy</code>)</li>
</ul>


<p>Ahora ya le prometimos a nuestra aplicación que manejaremos los recursos <code>tasks</code> y vemos en la <strong>tabla de rutas</strong> que espera que tengamos un controlador, así que hagamos eso realidad en el siguiente paso.</p>

<p>Más información sobre las rutas está en <a href="http://guides.rubyonrails.org/routing.html">las guías oficiales de rails</a></p>

<h3>3. El controlador y las vistas</h3>

<p>Así como comenzamos sabiendo que necesitaríamos representar nuestros recursos como modelos y usamos un generador para generar los archivos necesarios; ahora nos dimos cuenta que necesitamos un controlador, y también hay un generador:</p>

<pre><code>rails generate controller tasks index show new create edit update destroy
</code></pre>

<p>El generador de controladores recibe dos tipos de parámetros: el nombre del controlador (en este caso, <code>tasks</code>, como prometimos al router) y las acciones que ese controlador tendrá, en este caso, las siete acciones básicas que pueden hacerse sobre recursos.</p>

<p>Veamos qué generó:</p>

<pre><code>  create  app/controllers/tasks_controller.rb
   route  get "tasks/destroy"
   route  get "tasks/update"
   route  get "tasks/edit"
   route  get "tasks/create"
   route  get "tasks/new"
   route  get "tasks/show"
   route  get "tasks/index"
  invoke  erb
  create    app/views/tasks
  create    app/views/tasks/index.html.erb
  create    app/views/tasks/show.html.erb
  create    app/views/tasks/new.html.erb
  create    app/views/tasks/create.html.erb
  create    app/views/tasks/edit.html.erb
  create    app/views/tasks/update.html.erb
  create    app/views/tasks/destroy.html.erb
  invoke  test_unit
  create    test/functional/tasks_controller_test.rb
  invoke  helper
  create    app/helpers/tasks_helper.rb
  invoke    test_unit
  create      test/unit/helpers/tasks_helper_test.rb
  invoke  assets
  invoke    coffee
  create      app/assets/javascripts/tasks.js.coffee
  invoke    scss
  create      app/assets/stylesheets/tasks.css.scss
</code></pre>

<p>Si te fijás, creó el controlador <code>tasks_controller</code> en la carpeta <code>controllers</code>, agregó unas cuantas rutas a <code>config/routes.rb</code> (esas están incorrectas, las podemos borrar) y además generó una plantilla para cada una de las acciones. Como algo extra, notá que generó un archivo llamado <code>tasks_helper</code> (ya hablaremos de los helpers), un archivo para todo el javascript relacionado a las vistas (rails usa un dialecto de javascript muy similar a ruby llamado <a href="http://coffeescript.org/">coffeescript</a>) y otro archivo para todo el css relacionado a las vistas también (y rails usa otro dialecto de css, llamado <a href="http://sass-lang.com/">sass</a>)</p>

<p>Por ahora, concentrémonos en el controlador y las vistas. Nuestra meta en esta etapa será poder crear una <code>task</code>, poder mostrarla y poder jugar con la lista de <code>tasks</code></p>

<p>Notá que también agregó varias instrucciones <code>get</code> al router, esas podés borrarlas, ya de las rutas de nuestro recurso se encarga la instrucción <code>resources :tasks</code></p>

<h4>Creando una tarea: el formulario</h4>

<p>La clase base de todos los controladores, <code>ActionController::Base</code>, agrega una convención interesante: luego de ejecutar el método de una acción, va a buscar una plantilla en la carpeta de <code>views</code> del controller, la llenará y la usará como respuesta. De modo que, en el controlador <code>TasksController</code> (dentro de <code>app/controllers/tasks_controller.rb</code>), esta acción, por ejemplo:</p>

<pre><code>def new
end
</code></pre>

<p>Luego de ser ejecutada, responderá con un cuerpo html con el contenido de la plantilla <code>app/views/tasks/new.html.erb</code>. Así que llenemos <em>esa</em> plantilla con el formulario para crear un task.</p>

<p>Rails tiene varios <a href="http://guides.rubyonrails.org/form_helpers.html">métodos de ayuda</a> para formularios, usémoslos para generar un formulario para crear tareas:</p>

<pre><code>&lt;h1&gt;Create a task&lt;/h1&gt;
&lt;%= form_for @task do |f| %&gt;
  &lt;p&gt;
    &lt;%= f.label :description %&gt;
    &lt;%= f.text_area :description %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :priority %&gt;
    &lt;%= f.number_field :priority %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>Si te fijás, requiere que proveamos la variable <code>@task</code> en el binding. ¿Por qué una variable de instancia? Porque cuando rails llena plantillas, usa el binding de <strong>todo</strong> el controller (en cada solicitud, creará una <em>nueva</em> instancia del controlador), así que no nos servirían variables locales de métodos. En el archivo <code>app/controllers/tasks_controller.rb</code>, cambiemos el método <code>new</code> para que provea esa variable:</p>

<pre><code>def new
    @task = Task.new
end
</code></pre>

<p>Ahora, algo curioso del método <code>form_for</code> es que es inteligente: sabe qué tag crear basado en la variable que le demos:</p>

<ul>
<li>Usa el método <code>class</code> para saber de qué clase es instancia (en este caso, <code>Task</code>) y a partir de allí asume que tenemos un controlador con ese nombre en plural (<code>TasksController</code>) y que estamos usando las convenciones REST (es decir, que tenemos un método <code>create</code> relacionado a <code>POST /tasks</code> y un <code>update</code> relacionado a <code>PUT /tasks/:id</code>).</li>
<li>A partir del estado de la instancia (si es nueva o si ya está guardada en la base de datos) y las convenciones que mencionamos arriba, decide qué <code>action</code> y qué <code>method</code> usar (si es una nueva instancia, hará <code>POST</code> a <code>/tasks</code>) y si es una instancia ya guardada antes, hará <code>PUT</code> a <code>/tasks/:id</code>.</li>
</ul>


<p>Ahora bien, si ejecutamos el servidor:</p>

<pre><code>rails server
</code></pre>

<p>Llenamos el formulario y hacemos <em>submit</em>, podremos ver algo similar a esto en el log (la salida en terminal) del servidor (toda esta información, además de salir a la pantalla, también está en el archivo <code>log/development.log</code>):</p>

<pre><code>Started POST "/tasks" for 127.0.0.1 at 2012-05-20 01:48:08 -0600
Processing by TasksController#create as HTML
  Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"ph6/DQPV4Oju19f7y5KidRKrEa0AN3FAMuGAmqVcE/8=", "task"=&gt;{"description"=&gt;"asdfasdf", "priority"=&gt;"1"}, "commit"=&gt;"Create Task"}
  Rendered tasks/create.html.erb within layouts/application (0.3ms)
Completed 200 OK in 18ms (Views: 17.2ms | ActiveRecord: 0.0ms)
</code></pre>

<p>El <a href="http://railscasts.com/episodes/56-the-logger">log</a> es una de las piezas de información más importantes que rails nos provee: dice todo lo que pasa con las solicitudes que entran y cómo construye las respuestas, veamos en detalle cada línea de esta solicitud-respuesta:</p>

<p>En cuanto a la solicitud:</p>

<ul>
<li><code>Started POST "/tasks"</code> nos reporta qué ruta fue llamada por qué verbo, desde qué dirección remota a qué hora y fecha</li>
<li><code>Processing by TasksController#create as HTML</code> nos dice que a esa combinación de verbo + ruta le está asignando como responsable el método <code>create</code> de una instancia de <code>TasksController</code>, como esperaríamos. Es interesante notar que, por defecto, el formato en el que lidia con las solicitudes es <code>HTML</code>. Como mencionamos en los segmentos dinámicos arriba, podríamos pedirlo en otro agregando la extensión a la ruta  (<code>/tasks.json</code> pediría la respuesta como <code>JSON</code>, por ejemplo), o usando el ya conocido header <code>Accept</code>.</li>
<li>Los parámetros incluidos en la solicitud representados en un hash, nótese que entre estos está el hash <code>task</code>, que tiene las propiedades que introdujimos en el form (<code>utf8</code> fuerza a internet explorer a enviar los forms en unicode correcto, <code>authenticity_token</code> es parte de una <a href="http://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">estrategia de seguridad</a> para evitar que otros sitios simulen ser parte de la aplicación)</li>
</ul>


<p>En cuanto a la respuesta:</p>

<ul>
<li>Nos informa que llenó la plantilla <code>tasks/create.html.erb</code> porque ese es precisamente el comportamiento por defecto. En realidad no queremos eso, queremos que se cree una tarea y nos redirija, ya haremos eso.</li>
<li>Por último, nos dice que terminó de responder, y con qué estado.</li>
</ul>


<h4>Creando una tarea: la acción <code>create</code></h4>

<p>Ya que sabemos qué información tendríamos para crear una tarea, podríamos hacer algo como esto, aprovechando el método <code>params</code> que todos los controladores tienen, que devuelve un hash con los parámetros de la solicitud actual:</p>

<pre><code>@task = Task.create(params[:task])
</code></pre>

<p>También es buena idea, como hacíamos antes, redirigir al cliente a un lugar donde pueda ver que en efecto se creó la tarea. Esta vez, hagamos que vea la tarea individual usando el método <code>redirect_to</code>:</p>

<pre><code>redirect_to "/tasks/#{@task.id}"
</code></pre>

<p>Ahora bien, una buena idea en cualquier aplicación web es no depender de las rutas explícitas, porque podrían cambiar, y en su lugar aprovechar los <strong>alias</strong>, y los métodos que terminan en  <code>_path</code> o en <code>_url</code>:</p>

<pre><code>redirect_to task_path(id: @task.id)
</code></pre>

<p>Recordando que en la ruta para una tarea individual (a task path) necesitamos el segmento dinámico <code>:id</code>.</p>

<p>Pero puede ser más corto aún: como estamos tratando los <code>tasks</code> como recursos (recordá que hasta declaramos <code>resources :tasks</code> en el router), podemos dejar que rails asuma que estamos respetando REST, sólo darle la instancia y que él adivine la ruta:</p>

<pre><code>redirect_to @task
</code></pre>

<p>De modo que, en el controlador (en <code>app/controllers/tasks_controller.rb</code>), definiríamos el método <code>create</code> así:</p>

<pre><code>def create
    @task = Task.create params[:task]
    redirect_to @task
end
</code></pre>

<p>Al ser redirigidos a <code>/tasks/:id</code>, se estaría haciendo un <code>GET</code> a esa ruta. Según nuestra tabla de rutas (recordá que se obtiene con <code>rake routes</code>), de esta acción está a cargo el método <code>show</code>.</p>

<p>¿Qué queremos en el método <code>show</code>? Pues simplemente buscar una tarea con el identificador único incluido en la ruta y mostrarla en una plantilla, así que se vería  algo así:</p>

<pre><code>def show
    @task = Task.find(params[:id])
 end
</code></pre>

<p>Dos cosas a notar de arriba:
* Usamos el método <code>find</code> para encontrar <em>en la base de datos</em> mediante el identificador único.
* De entre los parámetros, sacamos el segmento dinámico <code>:id</code> (recordá que la ruta es <code>tasks/:id</code>)</p>

<p>Lo asignamos a una variable de instancia para que esté disponible en el <em>binding</em> de la instancia del controlador en esta solicitud y luego dejamos que el comportamiento por defecto (llenar la plantilla <code>show.html.erb</code>) ocurra. Editemos esa plantilla (en <code>app/views</code>)</p>

<pre><code>&lt;p&gt;
  Task with description &lt;%= @task.description %&gt;
  and priority &lt;%= @task.priority %&gt;
&lt;/p&gt;
&lt;%= link_to "All tasks", tasks_path %&gt;
</code></pre>

<p>Suficientemente sencillo. Fijate, sin embargo, en la última línea: usamos el método de ayuda (<a href="http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html">helper method</a>) <code>link_to</code> para generar un hipervínculo cuyo texto sea &ldquo;All tasks&rdquo; y su <code>href</code> sea la ruta que el método <code>tasks_path</code> devuelve (que es la ruta a la colección: <code>/tasks</code>). De este modo, podríamos ir a ver la lista de todos los tasks.</p>

<p>Y probemos con <code>rails server</code> otra vez crear una tarea en <code>/tasks/new</code> y esta vez debería crearla y redirigirnos a la tarea recién creada. Si todo funciona, <strong>es buen tiempo para hacer commit</strong>.</p>

<h4>Mostrando todas las tareas</h4>

<p>Ahora bien, para mostrar todas las tareas, ya sabemos que tenemos que encargarnos de la acción <code>index</code> en el controlador (<code>app/controllers/tasks_controller.rb</code>):</p>

<pre><code>def index
    @tasks = Task.all
end
</code></pre>

<p>Y de la plantilla correspondiente (<code>app/views/tasks/index.html.erb</code>):</p>

<pre><code>&lt;ol&gt;
  &lt;% @tasks.each do |task|%&gt;
    &lt;li&gt;
      &lt;%= task.description %&gt;
      &lt;%= link_to "show priority", task %&gt;
   &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ol&gt;
</code></pre>

<p>Un par de observaciones interesantes: estamos usando código encerrado entre <code>&lt;% %&gt;</code> (nótese la falta del signo igual) para ejecutar código de ruby, iterar entre todas las tareas. Y también, que de segundo parámetro al método <code>link_to</code> sólo estamos enviando la instancia de tarea, no una ruta. ¿Cómo funciona esto? Al igual que <code>form_for</code>, usa <a href="http://en.wikipedia.org/wiki/Reflection_(computer_programming">reflexión</a>) para adivinar que esta instancia pertenece a la clase <code>Task</code> y asumir que es un recurso y que, como tal, su ruta se vería <code>/tasks/:id</code>.</p>

<p>¿Qué pasaría si quisiéramos borrar una tarea? Si recordás HTTP, deberíamos hacer un <code>DELETE</code> a la ruta miembro. Rails nos permite hacer algo como lo siguiente:</p>

<pre><code>&lt;%= link_to "delete", task, :method =&gt; :delete, :confirm =&gt; "are you sure?" %&gt;
</code></pre>

<p>Que haría lo siguiente: usar javascript para preguntarnos si de veras queremos borrar el recurso y luego, siempre con javascript, enviar una solicitud <code>DELETE</code> a la ruta especificada en el <code>anchor</code>. Con eso en mente, nuestra plantilla se vería así:</p>

<pre><code>&lt;ol&gt;
  &lt;% @tasks.each do |task|%&gt;
    &lt;li&gt;
      &lt;%= task.description %&gt;
      &lt;%= link_to "show priority", task %&gt;
      &lt;%= link_to "delete", task, :method =&gt; :delete, :confirm =&gt; "are you sure?" %&gt;
   &lt;/li&gt;
  &lt;% end %&gt;
&lt;/ol&gt;
&lt;%= link_to "create a task", new_task_path %&gt;
</code></pre>

<p>Pero aún no tenemos nuestra acción <code>destroy</code> (que, según nuestra convención, reflejada en la tabla de rutas, es la que se encarga de un <code>DELETE</code>). Así que agreguémosla al controlador:</p>

<pre><code>def destroy
    Task.find_by_id(params[:id]).try(:delete)
    redirect_to tasks_path
end
</code></pre>

<p>Una observación: estamos usando el método <a href="http://guides.rubyonrails.org/active_support_core_extensions.html#try"><code>try</code></a>, que rails agrega a los objetos para que, si el objeto no es <code>nil</code>, lo ejecute, y si es <code>nil</code>, sólo devuelva <code>nil</code>. Además, estamos usando el método <code>find_by_id</code> en lugar de <code>find</code>, para que, si el objeto no existe, simplemente devuelva <code>nil</code>, en lugar de levantar una excepción.</p>

<h4>Validaciones en formularios</h4>

<p>Hasta este momento, nuestra acción de crear se ve así:</p>

<pre><code>def create
    @task = Task.create(params[:task])
    redirect_to @task
end
</code></pre>

<p>Pero está asumiendo que todo ha salido bien. ¿Cómo hacer para cuando las cosas salen mal, como validaciones que no pasan?</p>

<p>Recordemos que en lugar de usar el método <code>create</code>, podríamos crear la instancia y luego intentar guardarla. El método <code>save</code> nos devuelve un valor booleano que dice si la instancia se pudo guardar o no. Así que podríamos hacer que se vea así:</p>

<pre><code>def create
    @task = Task.new(params[:task])
    if @task.save
        redirect_to @task
    end
end
</code></pre>

<p>La gran pregunta es ¿qué hacer cuando una tarea <strong>no</strong> se salve? Idealmente, deberíamos <em>volver a mostrar el formulario</em> y allí mostrar los errores. Rails nos permite elegir qué plantilla usar mediante el método <code>render</code>, así que podemos cambiar la acción por esto</p>

<pre><code>def create
    @task = Task.new(params[:task])
    if @task.save
        redirect_to @task
    else
        render :new
    end
end
</code></pre>

<p>Para decirle que, si no pudimos guardar, se vuelva a mostrar el formulario. Pero ¿qué ganamos con mostrar el formulario de nuevo? No mucho si no hay forma de mostrar los errores, así que editemos el formulario (en <code>app/views/tasks/new.html.erb</code>):</p>

<pre><code>&lt;h1&gt;Create a task&lt;/h1&gt;
&lt;%= form_for @task do |f| %&gt;
  &lt;% if @task.errors.any? %&gt;
      &lt;h2&gt;Invalid task, the errors were:&lt;/h2&gt;
      &lt;ul&gt;
          &lt;% @task.errors.full_messages.each do |msg| %&gt;
            &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
          &lt;% end %&gt;
      &lt;/ul&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= f.label :description %&gt;
    &lt;%= f.text_area :description %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :priority %&gt;
    &lt;%= f.number_field :priority %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>Y ahora, si tratamos de guardar una tarea inválida, veremos una lista de errores al querer guardarla. Notá que usamos el métod <code>any?</code> para preguntarnos si la tarea tiene algún error y el método <code>full_messages</code> para obtener un arreglo con todos los mensajes de error.</p>

<h4>Actualizando tareas</h4>

<p>Como ya te imaginarás, para actualizar una tarea necesitamos tener un formulario en la plantilla <code>app/views/tasks/edit.html.erb</code> pero, antes de hacerlo, considerá ¿no sería ese formulario prácticamente idéntico al que está en la plantilla para uno nuevo? Si lo sospechás, es cierto: todo el formulario sería idéntico. Así que ¿será que lo copiamos y pegamos? ¡NO! Recordá un principio muy importante en programación: <em>Don&rsquo;t Repeat Yourself</em> (DRY). Afortunadamente, rails tiene el concepto de plantillas <a href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">parciales</a>.</p>

<p>Así que vamos a hacer lo siguiente en <code>app/views/tasks/edit.html.erb</code>:</p>

<pre><code>&lt;h1&gt;Edit a task:&lt;/h1&gt;
&lt;%= render 'form' %&gt;
</code></pre>

<p>Que básicamente dice: buscá en esta carpeta (<code>app/views/tasks</code>) una plantilla llamada <code>_form.html.erb</code> (notá el guión bajo al principio), llenala con el binding actual y ponela aquí.</p>

<p>Ahora, la plantilla <code>app/views/tasks/_form.html.erb</code> debería verse así:</p>

<pre><code>&lt;%= form_for @task do |f| %&gt;
  &lt;% if @task.errors.any? %&gt;
      &lt;h2&gt;Invalid task, the errors were:&lt;/h2&gt;
      &lt;ul&gt;
          &lt;% @task.errors.full_messages.each do |msg| %&gt;
            &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
          &lt;% end %&gt;
      &lt;/ul&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= f.label :description %&gt;
    &lt;%= f.text_area :description %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.label :priority %&gt;
    &lt;%= f.number_field :priority %&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= f.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></pre>

<p>Luego, necesitamos encargarnos de la acción <code>edit</code>: ella debería encontrar la tarea que queremos editar y ponerla disponible en el binding para el formulario</p>

<pre><code>def edit
 @task = Task.find(params[:id])
end
</code></pre>

<p>Y deberíamos poner un vínculo en la lista de tasks (en <code>app/views/tasks/index.html.erb</code>) que nos permita editar una tarea:</p>

<pre><code>&lt;%= link_to "edit this task", edit_task_path(task) %&gt;
</code></pre>

<p>Y, si vamos a editar una de nuestras tareas, deberíamos poder. Sabemos, también, que el formulario hará un <code>PUT</code> a <code>/tasks/:id</code>, y nuestra tabla de rutas dice que de esa combinación quien se encarga es el método <code>update</code> en el controlador, así que también editemos ese:</p>

<pre><code>def update
    @task = Task.find(params[:id])
    if @task.update_attributes(params[:task])
        redirect_to @task
    else
        render :edit
    end
end
</code></pre>

<p>Si te fijás, es muy similar al método create, con algunas diferencias:</p>

<ul>
<li>En vez de usar una nueva instancia, encontramos la instancia a editar con el método <code>find</code></li>
<li>En vez de usar el método save, usamos el método de instancia <code>update_attributes</code>, que recibe un hash con los atributos a actualizar y devuelve <code>true</code> si logró guardar el modelo.</li>
<li>Si no logró guardar los cambios, volvemos a mostrar el formulario.</li>
</ul>


<p>Con esto, ya tenemos las siete acciones básicas que se pueden hacer con un recurso, y ya podemos manipular recursos a través de http, representados como html.</p>

<p>Más información sobre los controladores está en las <a href="http://guides.rubyonrails.org/action_controller_overview.html">guías oficiales de rails</a>. Y sobre las vistas, podés leer sobre los <a href="http://guides.rubyonrails.org/layouts_and_rendering.html">layouts</a> y sobre los <a href="http://guides.rubyonrails.org/form_helpers.html">métodos de ayuda para formularios</a> también en las guías oficiales. Para saber sobre los métodos que rails agrega a los objetos de ruby, consultá aquí: <a href="http://guides.rubyonrails.org/active_support_core_extensions.html">http://guides.rubyonrails.org/active_support_core_extensions.html</a>.</p>

<h3>4. Cerrando esta iteración: subiendo la aplicación a heroku</h3>

<p>Para subir una aplicación a heroku, tenés que tener una <a href="http://api.heroku.com/signup">cuenta en heroku</a> y seguir el proyecto con git. Una observación a hacer: __tu carpeta <code>.git</code> debería estar al mismo nivel que los archivos de rails (es decir, la carpeta <code>app</code> y la carpeta <code>.git</code> deberían estar en la misma carpeta, si no, heroku no aceptará la aplicación). Todos los archivos de tu aplicación deben ser conocidos por git.</p>

<p>Para que de ahora en adelante heroku confíe en vos, ejecutá lo siguiente:</p>

<pre><code>heroku login
</code></pre>

<p>(te pedirá el correo y contraseña de tu cuenta en heroku).</p>

<p>Antes de poder usar heroku, necesitamos hacer una pequeña edición en nuestro <code>Gemfile</code>, donde dice</p>

<pre><code>gem 'sqlite3'
</code></pre>

<p>Sustituilo por las siguientes dos líneas:</p>

<pre><code>gem 'sqlite3', :group =&gt; :development
gem 'pg', :group =&gt; :production 
</code></pre>

<p>Y ejecutá, en terminal:</p>

<pre><code>bundle install --without production
</code></pre>

<p>Volvé a hacer un commit de todo, acabás de cambiar algunos de los gems de tu proyecto.</p>

<p>¿Qué acabamos de hacer? La opción <code>:group</code> del método <code>gem</code> le dice a <code>bundler</code> (la utilidad que maneja nuestras dependencias), en qué <a href="http://thirddirective.com/posts/14-rails-environments">entorno</a> estaremos usando cada gem: el gem <code>sqlite3</code> lo usaremos al programar (<code>development</code>) y el gem <code>pg</code> (para comunicarse con bases de datos en <a href="http://www.postgresql.org/">postgreSQL</a>), en un ambiente de producción (heroku es un ambiente de producción: porque es públicamente accesible).</p>

<p>Ahora, creá tu repositorio en heroku con la siguiente instrucción:</p>

<pre><code>heroku create --stack cedar
</code></pre>

<p>Que debería tener una salida similar a esta:</p>

<pre><code>Creating stark-moon-2137... done, stack is cedar
http://stark-moon-2137.herokuapp.com/ | git@heroku.com:stark-moon-2137.git
Git remote heroku added
</code></pre>

<p>Notá que el nombre antes de <code>herokuapp.com</code> es aleatorio, así que te saldrá uno diferente al que me salió a mí. Si la última línea (<code>Git remote heroku added</code>) no te aparece, agregá el repositorio de heroku manualmente con:</p>

<pre><code>git remote add heroku git@heroku.com:NOMBRE_ASIGNADO_POR_HEROKU.git
</code></pre>

<p>Es hora de subir el código de nuestra aplicación a heroku:</p>

<pre><code>git push heroku master
</code></pre>

<p>(estás subiendo el código a heroku, no a <code>origin</code>, que está en github)</p>

<p>Y deberías ver algo como esto:</p>

<pre><code>Counting objects: 129, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (113/113), done.
Writing objects: 100% (129/129), 29.82 KiB, done.
Total 129 (delta 23), reused 0 (delta 0)

-----&gt; Heroku receiving push
-----&gt; Ruby/Rails app detected
-----&gt; Installing dependencies using Bundler version 1.2.0.pre
       Running: bundle install --without development:test --path vendor/bundle --binstubs bin/ --deployment
       …
              Cleaning up the bundler cache.
-----&gt; Writing config/database.yml to read from DATABASE_URL
-----&gt; Preparing app for Rails asset pipeline
       Running: rake assets:precompile
-----&gt; Rails plugin injection
       Injecting rails_log_stdout
       Injecting rails3_serve_static_assets
-----&gt; Discovering process types
       Procfile declares types      -&gt; (none)
       Default types for Ruby/Rails -&gt; console, rake, web, worker
-----&gt; Compiled slug size is 15.7MB
-----&gt; Launching... done, v4
       http://stark-moon-2137.herokuapp.com deployed to Heroku
</code></pre>

<p>En este momento, tu aplicación ya está lista para ser visitada en heroku. Pero hay un problema: acabás de poner la aplicación en otra computadora, una que no sabe cuál es la estructura de tu base de datos (recordá que la base de datos <strong>no</strong> es parte de tu aplicación). Para que heroku esté al tanto de tu base de datos, tenés que ejecutar las migraciones allí también (esto sólo se debería correr cada vez que cambiés la estructura de la BD):</p>

<pre><code>heroku run rake db:migrate
</code></pre>

<p>Y deberías ver que las migraciones se ejecutaron:</p>

<pre><code>Running rake db:migrate attached to terminal... up, run.1
   Migrating to CreateTasks (20120514062804)
==  CreateTasks: migrating ====================================================
-- create_table(:tasks)
   -&gt; 0.0080s
==  CreateTasks: migrated (0.0082s) ===========================================
</code></pre>

<p>Ahora deberías poder entrar a tu aplicación, en la ruta <code>/tasks</code> (en el caso de este ejemplo, a <code>http://stark-moon-2137.herokuapp.com/tasks</code>) y usar la aplicación.</p>

<p>¡Felicidades, acabás de subir tu primera aplicación a internet!</p>

<p>Si todo está bien, deberías subir todos tus cambios a tu repositorio de github también.</p>

<h3>5. Extra: un controlador para la ruta raíz</h3>

<p>Si te fijás, en este punto sólo algo bajo <code>/tasks</code>. Si entrás a la ruta raíz (<code>/</code>) vas a ver una página por defecto de ruby on rails. Esa está en el archivo <code>public/index.html</code>. Borrémoslo:</p>

<pre><code>rm public/index.html
</code></pre>

<p>Y agreguemos esta línea dentro del router:</p>

<pre><code>root to: "tasks#index"
</code></pre>

<p>Ahí estamos simplemente diciendo: quiero que cuando se pida la ruta raíz, de esta también se encargue el método <code>index</code> de una instancia del controlador <code>tasks</code></p>

<p>Ahora bien, quizá no queremos ese tipo de ambigüedad, o quizá queremos que en la ruta raíz salga algo diferente. Creemos un controlador que no sea un recurso, simplemente algo aparte:</p>

<pre><code>rails g controller home index
</code></pre>

<p>Estamos creando un controlador llamado <code>home</code> con una acción <code>index</code>. En la plantilla (en <code>app/views/home/index.html.erb</code>):</p>

<pre><code>&lt;h1&gt;Tasks app&lt;/h1&gt;

&lt;%= link_to "See all tasks", tasks_path %&gt;
</code></pre>

<p>Y cambiamos la ruta raíz en <code>config/routes.rb</code> a:</p>

<pre><code>root to: "home#index"
</code></pre>

<p>Y ahora, en vez de ver la lista de tareas al pedir la ruta raíz (<code>/</code>), veremos la plantilla que acabamos de llenar. Acabamos de aprender, también, que podríamos hacer controladores que no tienen que ver, necesariamente, con un recurso.</p>

<h2>Iteración 2: Los usuarios</h2>

<h3>1. Usando <code>scaffold</code> para generar el código que manipula usuarios</h3>

<p>Ahora que ya tenemos las tareas, deberíamos ser capaces de asignarlas a usuarios. De modo que necesitamos un nuevo recurso: <code>User</code>.</p>

<p>Para con este recurso, podríamos hacer como antes y crear el modelo, acciones y vistas manualmente. Pero sería básicamente lo mismo que ya hicimos. Recordá: don&rsquo;t repeat yourself.</p>

<p>Rails, afortunadamente, nos permitiría generar todo de una vez con el generador de recursos (<code>rails generate resource</code>). Pero podemos ir un paso más allá y no sólo generar el recurso, sino ¡llenar el controlador y vistas de una sola vez! Para eso, usaremos un generador más:</p>

<pre><code>rails generate scaffold User email username
</code></pre>

<p>Lo que hicimos fue decir: &ldquo;generá todo lo necesario para manipular un recurso llamado <code>User</code> con propiedad <code>email</code> y <code>username</code> (si no especificás el tipo de datos de una propiedad, será <code>string</code> por defecto).</p>

<p>Deberías ver algo como esto:</p>

<pre><code>  invoke  active_record
  create    db/migrate/20120521015711_create_users.rb
  create    app/models/user.rb
  invoke    test_unit
  create      test/unit/user_test.rb
  create      test/fixtures/users.yml
   route  resources :users
  invoke  scaffold_controller
  create    app/controllers/users_controller.rb
  invoke    erb
  create      app/views/users
  create      app/views/users/index.html.erb
  create      app/views/users/edit.html.erb
  create      app/views/users/show.html.erb
  create      app/views/users/new.html.erb
  create      app/views/users/_form.html.erb
  invoke    test_unit
  create      test/functional/users_controller_test.rb
  invoke    helper
  create      app/helpers/users_helper.rb
  invoke      test_unit
  create        test/unit/helpers/users_helper_test.rb
  invoke  assets
  invoke    coffee
  create      app/assets/javascripts/users.js.coffee
  invoke    scss
  create      app/assets/stylesheets/users.css.scss
  invoke  scss
  create    app/assets/stylesheets/scaffolds.css.scss
</code></pre>

<p>Si te fijás, creó todo lo que nosotros habíamos creado en partes antes, pero no sólo eso, ¡sino que ya llenó de código el controlador y vistas! (¡andá ve!).</p>

<p>Algo diferente que vas a notar en el código generado es que todas las acciones en el controlador usan el método <a href="http://guides.rubyonrails.org/action_controller_overview.html#rendering-xml-and-json-data"><code>respond_to</code></a>. Ese método sirve para decidir, en base al formato pedido, cómo representar el recurso (recordá que poder tener varias representaciones es escencial para una arquitectura REST), usar ese método se ve así:</p>

<pre><code>respond_to do |format|
  format.html # index.html.erb
  format.json { render json: @users }
end
</code></pre>

<p>Que básicamente es: en base al formato pedido, si es html, dejar que nada pase (para que haga lo por-defecto, que es llenar y mostrar la plantilla <code>index.html.erb</code>, en el caso de la acción <code>index</code>) y, en el caso de que se pida <code>json</code>, mostrar un objeto json a partir del arreglo de usuarios. Para probarlo, podrías crear un par de usuarios y luego pedir (desde curl o el browser): <code>/users.json</code>, y verías un objeto JSON con la lista de usuarios. Recordá que en la tabla de rutas el segmento dinámico opcional <code>.:format</code> nos permite agregar el formato necesitado a la ruta.</p>

<p>Recordá que acabás de generar un modelo, de modo que necesitás correr la migración (después de hacer un commit):</p>

<pre><code>rake db:migrate
git push heroku master
heroku run rake db:migrate
</code></pre>

<p>Por último, podríamos agregar la siguiente línea a la página que vemos en la raíz (<code>app/views/home/index.html.erb</code>):</p>

<pre><code>&lt;%= link_to "All users", users_path %&gt;
</code></pre>

<p>Si ejecutás el servidor (<code>rails server</code>), vas a notar que la página se ve ligeramente mejor (los vínculos son grises, no azules, el tipo de letra ya no es times new roman, etc.) Esto es gracias a una <em>hoja de estilos</em> que se agregó: <code>app/assets/stylesheets/scaffolds.css.scss</code>, ¡también en eso nos ayudó rails!</p>

<h3>2. Relacionando usuarios a tareas</h3>

<p>Ahora llegamos a lo bueno ¿cómo hacer para relacionar usuarios a tareas?. La idea es simple: necesitamos saber, por cada tarea, quién está asignado, ¿no? Además, los usuarios tienen un identificador único, de modo que, sabiendo éste, sabríamos quién es el responsable de la tarea. En lenguaje de bases de datos, tendríamos que tener una columna más en cada fila de tarea: una columna que guarde el responsable de la tarea. Como va a ser el identificador del usuario, llamémosle <code>user_id</code>.</p>

<p>Para agregar una columna a la tabla de usuarios, puesto que hemos de cambiar la estructura de la base de datos, necesitamos una migración. Rails tiene un generador de migraciones con una convención interesante: si escribimos <code>AddXXXXToTABLE</code>, va a saber que queremos agregar una columna a la tabla <code>TABLE</code>, y generará una migración con las instrucciones adecuadas. En este caso, esperaría un parámetro más: la columna a agregar:</p>

<pre><code>rails g migration AddUserIdToTasks user_id:integer
</code></pre>

<p>una vez que ejecutés la migración (<code>rake db:migrate</code>), tu tabla tendrá un campo para el identificador de usuarios.</p>

<p>Pero eso fue a nivel de la base de datos, a nivel de los modelos también tenemos que informar de esta asociación, así que, en el modelo para tareas (<code>app/models/task.rb</code>), agregaríamos esta línea:</p>

<pre><code>class Task &lt; ActiveRecord::Base
    belongs_to :user
    …
    #el resto del código
end
</code></pre>

<p>Con <code>belongs_to</code> simplemente estamos avisándole a rails que cada instancia de este modelo pertenecerá a un usuario. Con esto, ya sabrá que tiene que buscar el propietario en una columna llamada <code>user_id</code> (por convención). Y no sólo eso, sino que también líneas como <code>task.user</code> nos darán una instancia completa de usuario, porque rails se encargará de buscar en la base de datos un usuario con el id que esté guardado en la instancia de task, automáticamente.</p>

<p>Asimismo, los usuarios también deberían estar avisados que las tareas les pertenecerán, así que en el modelo de usuario (<code>app/models/user.rb</code>), escribimos:</p>

<pre><code>class User &lt; ActiveRecord::Base
    has_many :tasks
end
</code></pre>

<p>Con esto, líneas como <code>user.tasks</code> funcionarán: nos devolverían el arreglo de todas las tareas que le pertenecen a un usuario.</p>

<p>Para saber más sobre asociaciones, consultá la <a href="http://guides.rubyonrails.org/association_basics.html">guía oficial de rails sobre asociaciones</a>.</p>

<p>Ahora bien, necesitamos reflejar en el formulario de tareas que éstas pueden pertenecer a un usuario. Para ello, necesitamos un campo en la plantilla parcial para el formulario (<code>app/views/tasks/_form.html.erb</code>) que nos permita elegir un usuario. Esto es un problema interesante: necesitaríamos poder elegir un identificador único dentro de todos los usuarios y asignarlo al campo <code>user_id</code>. En html existe el tag <code>select</code>, que funciona así</p>

<pre><code>&lt;select name="user_id"&gt;
    &lt;option value="1"&gt;lfborjas&lt;/option&gt;
    &lt;option value="2"&gt;johnnycash&lt;/option&gt;
&lt;/select&gt;
</code></pre>

<p>Si te fijás, usamos el tag <code>select</code> para nombrar el campo a llenar. Y el tag <code>option</code> para las opciones que habrían de salir. Las opciones tienen un valor en el atributo <code>value</code> que es el que será enviado en el formulario, y otro dentro del tag que sólo se mostrará. Rails tiene un <em>helper</em> que nos ayuda con todo eso: <code>collection_select</code>. Agreguemos esto dentro del formulario en <code>app/views/tasks/_form.html.erb</code>:</p>

<pre><code>&lt;%= f.label :user %&gt;
&lt;%= f.collection_select :user_id, User.all, :id, :username %&gt;
</code></pre>

<p>Que básicamente es: quiero tener de opciones para el campo <code>user_id</code> a todos los usuarios (<code>User.all</code>) y que el valor de las opciones sea el <code>id</code> de cada instancia y lo que el usuario vea sea el <code>username</code> de cada instancia.</p>

<h3>3. Viendo las tareas de cada usuario</h3>

<p>Ahora que ya podemos asignarle tareas a un usuario, deberíamos poder ver todas las tareas asignadas a un usuario. Idealmente, deberíamos hacerlo a través de una url clara como <code>/users/lfborjas/tasks</code> o, usando segmentos dinámicos, <code>/users/:id/tasks</code>. Hay dos cosas a hacer:</p>

<pre><code>resources :users do
    get tasks, on: :member
end

tasks_user GET    /users/:id/tasks(.:format) users#tasks

def tasks
    @tasks = User.find_by_username(params[:id]).tasks
    render 'tasks/index'
end

def to_param
   username
end
</code></pre>

<h3>3. Autenticación</h3>

<pre><code>rails g migration AddPasswordToUsers password_digest:string

gem 'bcrypt-ruby', '~&gt; 3.0.0'

bundle install --without production
rake db:migrate

class User &lt; ActiveRecord::Base
    has_secure_password
    attr_accessible :username, :email, :password, :password_confirmation
    validates_uniqueness_of :username, :email
end

 &lt;div class="field"&gt;
&lt;%= f.label :password %&gt;&lt;br /&gt;
&lt;%= f.password_field :password %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :password_confirmation %&gt;&lt;br /&gt;
    &lt;%= f.password_field :password_confirmation %&gt;
  &lt;/div&gt;

rails g controller sessions 
</code></pre>

<p><a href="http://railscasts.com/episodes/250-authentication-from-scratch-revised">http://railscasts.com/episodes/250-authentication-from-scratch-revised</a> y <a href="http://railscasts.com/episodes/250-authentication-from-scratch">http://railscasts.com/episodes/250-authentication-from-scratch</a></p>

<h2>Más recursos</h2>

<ul>
<li><a href="http://railscasts.com/">Railscasts</a></li>
<li><a href="http://guides.rubyonrails.org/">Rails Guides</a></li>
<li><a href="http://api.rubyonrails.org">Rails API Docs</a></li>
<li><a href="http://ruby.railstutorial.org/ruby-on-rails-tutorial-book">Rails Tutorial</a></li>
<li><a href="http://railsforzombies.com/">Rails for Zombies</a></li>
<li><a href="http://tutorials.jumpstartlab.com/">Jumpstart Labs</a></li>
</ul>


<h2>Referencias</h2>

<ul>
<li><a href="http://tutorials.jumpstartlab.com/projects/blogger.html">A first rails app</a></li>
<li><a href="http://railscasts.com/episodes/310-getting-started-with-rails">Getting started with rails</a></li>
<li><a href="http://railscasts.com/episodes/250-authentication-from-scratch-revised?view=asciicast">Authentication from scratch</a></li>
</ul>

</body>
</html>